<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<link rel="shortcut icon" href="favicon.ico"/>

	<title>Augenschlepper</title>


	<style>	
		@font-face {
	      font-family: embeddedfont;
	      src: url('AmaticSC-Regular.ttf');
	    }

		:root {
		 /* --bg: #0471b6;
		  --fg: #7bc8ff;
		  --fg-faint: #107cc5;*/

		  --bg: white;
		  --fg: black;
		  --fg-faint: rgba(0,0,0,0.2);
		  --bg-mauerfüllung : white;
		  --bg-mauerlinie : rgba(0,0,0,0.2);
		  --bg-seite : rgb(100,150,255);
		  --seite-schaten : rgba(0,0,0,0.2);
		}


	    .text { 
			font-family: 'embeddedfont', cursive;
	    	font-size: 7pt; 	
	    	color: var(--fg);
	    }

	    .scoretext { 
			font-family: 'helvetica';
	    	font-size: 4pt; 
	    	font-weight: bold;	
	    	color: blue;
	    	fill: var(--bg);
	    	stroke: none;	
	    	dominant-baseline: central;
	    	text-anchor: middle;
	    }


		body{
			background-color: var(--bg-seite);
			width: 100%;
			margin: 0;
			padding:0;
			overflow: hidden;;
			text-align: center;
			min-height: 100vh;
			display: flex;
			align-items: center;
			justify-content: center;


		}

		.würfel-hg {
			stroke:none;	
			fill:url(#diagonalHatch);
		}

		.würfel-has0 {
			stroke:none;	
			fill:url(#dh0);
		}

		.würfel-has1 {
			stroke:none;	
			fill:url(#dh1);
		}

		.würfel-has2 {
			stroke:none;	
			fill:url(#dh2);
		}

		.würfel-has3 {
			stroke:none;	
			fill:url(#dh3);
		}

		.würfel-has4 {
			stroke:none;	
			fill:url(#dh4);
		}

		.würfel-has5 {
			stroke:none;	
			fill:url(#dh5);
		}

		.würfel-has6 {
			stroke:none;	
			fill:url(#dh6);
		}

		.würfel-has7 {
			stroke:none;	
			fill:url(#dh7);
		}

		.würfel-has8 {
			stroke:none;	
			fill:url(#dh8);
		}

		.würfel-umriss {
			stroke: var(--fg);
			stroke-width:0.5;		
			fill:none;
		}

		.seite {
			fill:var(--bg);
			stroke:none;
		}
  		
		.seite-schaten {
			fill:var(--seite-schaten);
			stroke:none;
		}

		.schaten {
			fill:var(--bg);
			stroke:none;
		}
  		#svgcontainer, #bgcontainer {
			background-color: none;
			width: 100%;
			margin: 0;
			padding:0;
			overflow: hidden;;
			text-align: center;
			min-height: 100vh;
			display: flex;
			align-items: center;
			justify-content: center;
			padding-top: 50px;
			margin-top: 50px;
  		}

		svg {
			 position:fixed; 
			 top:0; 
			 left:0; 
			 height:100%; 
			 width:100%
		}
		
		.auge_leer{
			fill:var(--bg);
			stroke:var(--fg);
		}

		.auge_dunkel{
			fill:var(--fg);
			stroke:var(--fg);
		}

		.feuer{
			fill:var(--fg);
			stroke:none;
			stroke-miterlimit:10;
		}
		
		.spieler_innen {
			fill:none;
			stroke:var(--fg);
			stroke-linecap:round;
			stroke-miterlimit:10;
		}


		.spieler_auserer_feuerrand {
			stroke:var(--fg);
			stroke-width:3;
			stroke-miterlimit:10;
			stroke-linecap: round;
		}

		.spieler_auserer_feuerrand_innen {
			stroke:var(--bg);
			stroke-width:2;
			stroke-miterlimit:10;
			stroke-linecap: round;
		}

		.raster-dick {
			stroke:var(--fg);
			stroke-width:0.7;
			/*stroke-dasharray:0.2;*/
		}

		.raster {
			stroke:var(--fg);
			stroke-width:0.2;
			/*stroke-dasharray:0.2;*/
		}

		.raster-sub {
			stroke:var(--fg-faint);
			stroke-width:0.2;
			/*stroke-dasharray:0.2;*/
		}

		.mauer {
			stroke:var(--fg);
			stroke-width:0.5;
			fill:url(#diagonalHatch);
			fill-rule: evenodd;
		}

		.hatchfill{
			stroke:none;
			fill:var(--bg-mauerfüllung);
		}

		.hatchstroke{
			stroke:var(--fg-faint); 
			stroke-width:0.3;
		}

	</style>

</head>

<body>

<script>


var level=0;

var spielstand=[0,0];
var entitäten=[];
var würfeln=[];


var levels = [
	[
		"o...............",
		".........o....o.",
		"..o..S..........",
		"...o............",
		"..........o.o...",
		"......oo...o....",
		".o........o.o...",
		"................",
	],
	[
		"###.",
		"#.#.",
		"###.",
		"....",
		"....."
	],
	[
		"##..",
		".##.",
		"....",
		"....",
		"....."
	],

]

var leveloff_x=0;
var leveloff_y=0;
var level_grid_s=0;

var sprache="DE";

function S(de,en){
	if (sprache==="DE"){
		return de;
	} else {
		return en;
	}
}


var gameName="pipschlepper"
function setVal(key,val){
	if (typeof(Storage) !== "undefined") {
	    localStorage.setItem(gameName+key,val);
	}
}

let f = x => x*2

function getVal(key, default_val){
	if (typeof(Storage) !== "undefined") {
	    let val = localStorage.getItem(gameName+key);
	    if (val===null){
	    	return default_val;
	    } else {
	    	return val;
	    }
	} else {
    	return default_val;
	}
}


	function rotUZS(n){
		switch(n){
			case 0://up
				return 3;
			case 1://down
				return 2;
			case 2://left
				return 0;
			case 3://right
				return 1;
		}
	}

	function rotGUZS(n){
		switch(n){
			case 0://up
				return 2;
			case 1://down
				return 3;
			case 2://left
				return 1;
			case 3://right
				return 0;
		}
	}

	function nebenKoord(x,y,d){//right von der punkt
		switch(d){
			case 0://u
				return [x,y-1];
			break;
			case 1://d
				return [x-1,y];
			break;
			case 2://l
				return [x-1,y-1];
			break;
			case 3://r
				return [x,y];
			break;
		}
	}

	function dirToDelta(d){
		switch(d){
			case 0://u
				return [0,-1];
			break;
			case 1://d
				return [0,1];
			break;
			case 2://l
				return [-1,0];
			break;
			case 3://r
				return [1,0];
			break;
		}
	}

	let keyAllowed = {};

	function onFocus(e){
		keyAllowed = {};
	}

	function onKeyup(e){
		keyAllowed [e.which] = true;
	}

	function onTitelInput(k){

	}

	function getSpieler(){
		for (var i=0;i<entitäten.length;i++){
			if (entitäten[i][0]==="S"){
				return entitäten[i];
			}
		}
	}

	function würfelAt(x,y){
		return würfelPunktzahl(x,y,würfeln)>0;
	}

	function getPipAt(x,y){
		for (var i=0;i<entitäten.length;i++){
			var e = entitäten[i];
			if (e[0]!=="S" && e[1]===x && e[2]===y){
				return e;
			}
		}
		return null;
	}

	function inBounds(x,y){

		var curlevel=levels[level];
		var level_b=curlevel[0].length;
		var level_h=curlevel.length;

		if (x<0||y<0||x>=level_b||y>=level_h){
			return false;
		}
		return true;
	}

	function emptySpace(x,y,würfelsperren){
		var curlevel=levels[level];
		var level_b=curlevel[0].length;
		var level_h=curlevel.length;

		if (x<0||y<0||x>=level_b||y>=level_h){
			return false;
		}
		for (var i=0;i<entitäten.length;i++){
			var e = entitäten[i];
			if (e[1]===x&&e[2]===y){
				return false;
			}
		}
		if (würfelsperren===true){
			if (würfelAt(x,y)){
				return false;
			}
		}
		return true;
	}

	function onSpielInput(k){
		console.log(k);
		if (k<4){
			var player = getSpieler();
			var [dx,dy]=dirToDelta(k);
			var tx = player[1]+dx;
			var ty = player[2]+dy;
			if (inBounds(tx,ty)===false){
				return;
			}
			let pip = getPipAt(tx,ty); 
			if (pip!==null && pip[0]=="o"){
				var ttx=tx+dx;
				var tty=ty+dy;
				if (emptySpace(ttx,tty,true)){
					pip[1]=ttx;
					pip[2]=tty;
					pip=null;

					würfelMelden();
				}
			}
			if (pip===null)
			{
				player[1]=tx;
				player[2]=ty;
			}

	    	render();
	    	zustandSpeichern();
		} else if (k===5){//undo
			rückgängig();
			render();
		} else if (k===6){//restart
			neustart();
			render();
		}


	}

	function onInput(k){
		if (k===7&&gameState!=="TITEL"){
			setGameState("TITEL");
			return;
		}
		switch(gameState){
			case "TITEL":
			onTitelInput(k);
			break;
			case "SPIEL":
			onSpielInput(k);
			break;
		}
	}

	function checkKey(e) {
	    e = e || window.event;

		if (keyAllowed [e.which] === false) {
			if (e.keyCode == '88' || e.keyCode =='32'||e.keyCode =='13'||e.keyCode =='68'){
				return;
			}
		}
		keyAllowed [e.which] = false;
		 
	    if (e.keyCode == '38') {
	        // up arrow
	    	onInput(0);
	    	e.preventDefault();
	    }
	    else if (e.keyCode == '40') {
	        // down arrow
	    	onInput(1);
	    	e.preventDefault();
	    }
	    else if (e.keyCode == '37') {
	       // left arrow
	    	onInput(2);
	    	e.preventDefault();
	    }
	    else if (e.keyCode == '39') {
	       // right arrow
	    	onInput(3);
	    	e.preventDefault();
	    } else if (e.keyCode == '88' || e.keyCode =='32'||e.keyCode =='13'||e.keyCode =='68'){
	    	onInput(4);
	    	e.preventDefault();
	    } else if (e.keyCode=='90'||e.keyCode=='85'){//z or u
	    	onInput(5);
	    } else if (e.keyCode=='82'){//r
	    	onInput(6);
	    } else if (e.keyCode=='27'){//escape
	    	onInput(7);
	    } 

	}

	function render(){
		switch(gameState){
			case "TITEL":
				renderTitel();
				break;
			case "SPIEL":
				renderSpiel();
				break;
		}
	}

	function renderTitel(){

	}

	function GuteKoordinate(mauermaske){
		var x=-1;
		var y=-1;
		for (var j=0;j<mauermaske.length;j++){
			var zeile=mauermaske[j];
			for (var i=0;i<zeile.length;i++){
				if (zeile[i]===1){
					x=i;
					y=j;
					break;
				}
			}
		}

		while (x>0){
			if (zeile[y][x-1]===1){
				x--;
			} else {
				break;
			}
		}

		return [x,y];
	}


	function getPunkt(x,y,raster){
		if (x<0||y<0||x>=raster[0].length||y>=raster.length){
			return 0;
		}
		return raster[y][x];
	}


	function removeKante(kante,kanten){
		for (var i=0;i<kanten.length;i++){
			var k = kanten[i];
			if (k[0]===kante[0]&&k[1]===kante[1]&&k[2]===kante[2]){
				kanten.splice(i,1);
				return;
			}
		}
		console.log("error kante not found")
	}
	function Konturausrechnung(ebene,sx,sy,sdir,kanten){
		var x = sx;
		var y = sy;

		var dir = sdir;

		var coords=[[x,y,dir]];
		//im Uhrzeigersinn
		do {

			let [dx,dy]=dirToDelta(dir);
			
			var [nx,ny] = nebenKoord(x,y,dir);
			removeKante([nx,ny,rotGUZS(dir)],kanten);

			x+=dx;
			y+=dy;
			var ldir = rotGUZS(dir)
			
			var [nk_l_x,nk_l_y]=nebenKoord(x,y,ldir);
			
			var [nk_x,nk_y]=nebenKoord(x,y,dir);

			if (getPunkt(nk_l_x,nk_l_y,ebene)===1){
				dir=ldir;				
			} else if (getPunkt(nk_x,nk_y,ebene)===1){
				//dir=gleich
			} else {
				dir = rotUZS(dir);
			}

			coords.push([x,y,dir]);
		} while (x!=sx || y!=sy || dir!=sdir)

		return coords;
	}

	function Kanten(mauermaske){
		var result=[];
		for (var j=0;j<mauermaske.length;j++){
			var zeile=mauermaske[j];
			for (var i=0;i<zeile.length;i++){
				var c = zeile[i];
				if (c===0){
					continue;
				}
				var c_oben = getPunkt(i,j-1,mauermaske);
				var c_unten = getPunkt(i,j+1,mauermaske);
				var c_links = getPunkt(i-1,j,mauermaske);
				var c_rechts = getPunkt(i+1,j,mauermaske);
				if (c_oben===0){
					result.push([i,j,0]);
				}
				if (c_unten===0){
					result.push([i,j,1]);
				}
				if (c_links===0){
					result.push([i,j,2]);
				}
				if (c_rechts===0){
					result.push([i,j,3]);
				}
			}
		}
		return result;
	}

	function MauerTrennen(curlevel){

		var level_b=curlevel[0].length;
		var level_h=curlevel.length;

		var counter=0;
		var flutfüllung=[];

		for (var j=0;j<level_h;j++){
			var zeile=[]
			for (var i=0;i<level_b;i++){
				if (curlevel[j].charAt(i)=="#"){
					zeile.push(counter);
					counter++;
				} else {
					zeile.push(-1);
				}
			}			
			flutfüllung.push(zeile);
		}

		//flutfüllen
		var geändert=true;
		while(geändert){
			geändert=false;

			for (var i=0;i<level_b;i++){
				for (var j=0;j<level_h;j++){
					var p1 = flutfüllung[j][i];
					if (p1 === -1){
						continue;
					}

					if (i+1<level_b){
						var p2 = flutfüllung[j][i+1];
						if (p2>=0 && p2!==p1){
							var min = p1<p2?p1:p2;
							flutfüllung[j][i]=min;
							flutfüllung[j][i+1]=min;
							geändert=true;
						}
					}

					if (j+1<level_h){
						var p2 = flutfüllung[j+1][i];
						if (p2>=0 && p2!==p1){
							var min = p1<p2?p1:p2;
							flutfüllung[j][i]=min;
							flutfüllung[j+1][i]=min;
							geändert=true;
						}
					}

					//schräg
					// if (i+1<level_b && j+1<level_h){
					// 	var p2 = flutfüllung[j+1][i+1];
					// 	if (p2>=0 && p2!==p1){
					// 		var min = p1<p2?p1:p2;
					// 		flutfüllung[j][i]=min;
					// 		flutfüllung[j+1][i+1]=min;
					// 		geändert=true;
					// 	}
					// }
				}
			}
		}
		var getrennt=[];
		for (var c=0;c<counter;c++){
			var indexGefunden=false;
			var ebene=[];

			for (var j=0;j<level_h;j++){
				var zeile=[]
				for (var i=0;i<level_b;i++){
					if (flutfüllung[j][i]==c){
						zeile.push(1);
						indexGefunden=true;
					} else {
						zeile.push(0);
					}
				}			
				ebene.push(zeile);
			}

			if (indexGefunden){
				getrennt.push(ebene);
			}
		}


		var konturen=[];
		for ( var i=0;i<getrennt.length;i++ ){
			var ebene = getrennt[i];
			var kanten = Kanten(ebene);

			while(kanten.length>0){
				let [x,y,dir]=kanten[0];
				dir = rotUZS(dir);
				switch(dir){
					case 0:
					y++;
					break;
					case 1:
					x++;
					break;
					case 2:
					x++;
					y++;
					break;
					case 3:
					break;
				}
				var ol = kanten.length;
				var linie = Konturausrechnung(ebene,x,y,dir,kanten);
				konturen.push(linie);
				if (kanten.length===ol){
					break;
				}
			}
		}
		return konturen;
	}

	function linksvon(dir1,dir2){
		return rotUZS(dir1)===dir2;
	}
	function rechtsvon(dir1,dir2){
		return rotGUZS(dir1)===dir2;
	}

	function printText(x,y,s){
		 var result = `<text x="${x+3}" y="${y+12-1.5}" class="text">${s}</text>`;
		 return result;

	}

	var lastlb=-1;
	var lastlh=-1;

	function renderSpiel(){

		var curlevel=levels[level];

		var level_b=curlevel[0].length;
		var level_h=curlevel.length;
		var genbg = lastlb!==level_b||lastlh!==level_h;
		lastlb=level_b;
		lastlh=level_h;

		var linie_exterior=4;
		var linie_seite_rand=2;

		var o_bildschirm_rand_x=(linie_exterior+linie_seite_rand)/2;
		var o_bildschirm_rand_y=(linie_exterior+linie_seite_rand)/2+24;


		var o_seite_rand_x=linie_exterior/2;
		var o_seite_rand_y=linie_exterior/2;

		var o_bildschirm_zelle_g_b=12;
		var o_bildschirm_zelle_g_h=12;

		var o_spielplatz_b=level_b*o_bildschirm_zelle_g_b;
		var o_spielplatz_h=level_h*o_bildschirm_zelle_g_h;


		var o_screen_b=o_spielplatz_b+2*o_bildschirm_rand_x;
		var o_screen_h=o_spielplatz_h+2*o_bildschirm_rand_y-24+linie_exterior/6;

		var o_seite_b=o_spielplatz_b+linie_seite_rand;
		var o_seite_h=o_spielplatz_h+linie_seite_rand+24;

		var svg=`
<svg id="console" viewBox="0 0 ${o_screen_b} ${o_screen_h}" xmlns="http://www.w3.org/2000/svg">

<defs> 



<pattern id="diagonalHatch" width="0.1em" height="0.1em" patternTransform="rotate(45 0 0)" patternUnits="userSpaceOnUse">
  <rect x="0" y="0" width="1em" height="1em" class="hatchfill"/>
  <line x1="0" y1="0" x2="0" y2="10" class="hatchstroke" />
</pattern>



</defs>



`
let svgbg=``;

if (genbg){
svgbg=`
<svg id="console" viewBox="0 0 ${o_screen_b} ${o_screen_h}" xmlns="http://www.w3.org/2000/svg">

<defs> 



</defs>


<rect x="${o_seite_rand_x+linie_exterior/4}" y="${o_seite_rand_y+linie_exterior/4}" width="${o_seite_b}" height="${o_seite_h}" class="seite-schaten"" />

<rect x="${o_seite_rand_x}" y="${o_seite_rand_y}" width="${o_seite_b}" height="${o_seite_h}" class="seite"" />


`;

// svg+=`
// `

// svg+=`
// <polygon points="100,10 40,198 190,78 10,78 160,198" style="fill:lime;stroke:purple;stroke-width:5;fill-rule:nonzero;"/>
// `;

		
	
		//rasterlinien
		for (var i=0;i<=level_b;i++){
			var lx_1 = o_bildschirm_rand_x+o_bildschirm_zelle_g_b*i;
			var ly_1 = o_bildschirm_rand_y;
			var lx_2 = o_bildschirm_rand_x+o_bildschirm_zelle_g_b*i;
			var ly_2 = o_bildschirm_rand_y+o_bildschirm_zelle_g_h*level_h;

			// if (i>0)
			{
				svgbg+=`<line x1="${lx_1}" y1="${ly_1}" x2="${lx_2}" y2="${ly_2}" class="raster" />`
			}
			if (i<level_b){
				for (var j=1;j<6;j++){
					lx_1+=o_bildschirm_zelle_g_b*1/6
					lx_2+=o_bildschirm_zelle_g_h*1/6
					svgbg+=`<line x1="${lx_1}" y1="${ly_1}" x2="${lx_2}" y2="${ly_2}" class="raster-sub" />`
				}
			}
		}
		for (var j=0;j<=level_h;j++){
			var lx_1 = o_bildschirm_rand_x;
			var ly_1 = o_bildschirm_rand_y+o_bildschirm_zelle_g_h*j;
			var lx_2 = o_bildschirm_rand_x+o_bildschirm_zelle_g_b*level_b;
			var ly_2 = o_bildschirm_rand_y+o_bildschirm_zelle_g_h*j;

			// if (j>0)
			{
				svgbg+=`<line x1="${lx_1}" y1="${ly_1}" x2="${lx_2}" y2="${ly_2}" class="raster" />`
			}		
			if (j<level_h){
				for (var i=1;i<6;i++){
					ly_1+=o_bildschirm_zelle_g_b*1/6
					ly_2+=o_bildschirm_zelle_g_h*1/6
					svgbg+=`<line x1="${lx_1}" y1="${ly_1}" x2="${lx_2}" y2="${ly_2}" class="raster-sub" />`
				}
			}
		}
}
		var konturen = MauerTrennen(curlevel);
		let path = `<path class="mauer" d="`;
		for (var i=0;i<konturen.length;i++){
			var kontur=konturen[i];
			var letzte_x=0;
			var letzte_y=0;
			var letzte_dir=0;
				for (var j=0;j<kontur.length;j++){
					var punkt=kontur[j];
					var dir = punkt[2];
					var px = punkt[0]*12+o_bildschirm_rand_x;
					var py = punkt[1]*12+o_bildschirm_rand_y;
					var tx = 0;
					var ty = 0;
					switch(dir){
						case 0:
							px++;
							py-=2;
							tx=px;
							ty=py-8;
							break;
						case 1:
							px--;
							py+=2;
							tx=px;
							ty=py+8;
							break;
						case 2:
							px-=2;
							py--;
							tx=px-8;
							ty=py;
							break;
						case 3:
							px+=2;
							py++;
							tx=px+8;
							ty=py;
							break;
					}
					if (j===0){
						path+=`M${px} ${py} L${tx} ${ty}`;
					} else {
						if (letzte_dir===dir){
							path+=` L${px} ${py} L${tx} ${ty}`;
						} else if(linksvon(dir,letzte_dir)){

							let [dx,dy]= dirToDelta(dir);
							let [letzte_dx,letzte_dy]= dirToDelta(letzte_dir);
							
							var nudge_letzte_dx = letzte_x+2*letzte_dx;
							var nudge_letzte_dy = letzte_y+2*letzte_dy;

							var nudge_px = px-2*dx;
							var nudge_py = py-2*dy;

							path+=` L${nudge_letzte_dx} ${nudge_letzte_dy} A 1 1 0 0 0 ${nudge_px} ${nudge_py} L${tx} ${ty}`;
							//concave
						} else {
							//convex
							path+=` A 1 1 0 0 1 ${px} ${py} L${tx} ${ty}`;
						}
					}
					letzte_x=tx;
					letzte_y=ty;
					letzte_dir=dir;
				}


		}
		path+=` "/>`;
		svg+=path;

		for (var i=0;i<würfeln.length;i++){
			var würfel=würfeln[i];
			var wx=1+o_bildschirm_rand_x+o_bildschirm_zelle_g_b*würfel[0];
			var wy=1+o_bildschirm_rand_y+o_bildschirm_zelle_g_h*würfel[1];
			var wg=12*3-2;
			
			svg+=`<rect class="würfel-hg" x="${wx}" y="${wy}" width="${wg}" height="${wg}" rx="5">`

			 if (würfel[2]===0){
				würfel[2]=1;
				// svg+=`<animate attributeName="opacity" from="0" to="1" dur="0.2s"  />`;
			 }

			svg+=`</rect>`

			// svg+=`<g class="#${entität[0]}" transform="translate(${ox},${oy})">`
		}


		// for (var i=0;i<würfeln.length;i++){
		// 	var würfel=würfeln[i];
		// 	var wx=1+o_bildschirm_rand_x+o_bildschirm_zelle_g_b*würfel[0];
		// 	var wy=1+o_bildschirm_rand_y+o_bildschirm_zelle_g_h*würfel[1];
		// 	var wg=12*3-2;
		// 	var hashindex = (würfel[0]%3)*3+(würfel[1]%3);
		// 	svg+=`<rect class="würfel-has${hashindex}" x="${wx}" y="${wy}" width="${wg}" height="${wg}" rx="5"/>`

		// }

		//Entitäten
		for (var i=0;i<entitäten.length;i++){
			var entität=entitäten[i];
			var ox=o_bildschirm_rand_x+o_bildschirm_zelle_g_b*entität[1];
			var oy=o_bildschirm_rand_y+o_bildschirm_zelle_g_h*entität[2];
			svg+=`<g class="#${entität[0]}" transform="translate(${ox},${oy})">
`			
			var lx = o_bildschirm_rand_x+o_bildschirm_zelle_g_b*entität[3];
			var ly = o_bildschirm_rand_y+o_bildschirm_zelle_g_h*entität[4];
			if (ox!==lx||oy!==ly){
				// svg+=`<animateTransform attributeName="transform"
	   //                        attributeType="XML"
	   //                        type="translate"
	   //                        from="${lx} ${ly}"
	   //                        to="${ox} ${oy}"
	   //                        dur="0.1s"/>`;
	            entität[3]=entität[1];
	            entität[4]=entität[2];
	        }
			switch(entität[0]){
				case "F"://FEUER
					svg+=`
					<path class="feuer" d="M1,6a4.72,4.72,0,0,0,5,5,4.72,4.72,0,0,0,5-5,7.65,7.65,0,0,0-1-4S8.85,6,8,6,6,2,6,2,4.85,6,4,6,2,2,2,2A7.77,7.77,0,0,0,1,6Z"/>
					`;
				break;
				// case "S"://SPIELER
				// svg+=`
				// 	<line class="spieler_innen" x1="5" y1="3" x2="7" y2="3"/>
				// 	<line class="spieler_innen" x1="4" y1="9" x2="6" y2="6.43"/>
				// 	<line class="spieler_innen" x1="8" y1="9" x2="6" y2="6.43"/>
				// 	<line class="spieler_innen" x1="6" y1="3.86" x2="3" y2="5.57"/>
				// 	<line class="spieler_innen" x1="9" y1="5.57" x2="6" y2="3.86"/>
				// 	<line class="spieler_innen" x1="6" y1="6.43" x2="6" y2="3"/>
				// `
				// break;	
				case "o"://Auge
				svg+=`
					<circle class="auge_leer" cx="6" cy="6" r="3"  />
					`
				break;			
				case "S":
				svg+=`
					<line class="spieler_auserer_feuerrand" x1="5" y1="3" x2="7" y2="3"/>
					<line class="spieler_auserer_feuerrand" x1="4" y1="9" x2="6" y2="6.43"/>
					<line class="spieler_auserer_feuerrand" x1="8" y1="9" x2="6" y2="6.43"/>
					<line class="spieler_auserer_feuerrand" x1="6" y1="3.86" x2="3" y2="5.57"/>
					<line class="spieler_auserer_feuerrand" x1="9" y1="5.57" x2="6" y2="3.86"/>
					<line class="spieler_auserer_feuerrand" x1="6" y1="6.43" x2="6" y2="3"/>
					<line class="spieler_auserer_feuerrand" x1="5" y1="3" x2="7" y2="3"/>


					<line class="spieler_auserer_feuerrand_innen" x1="5" y1="3" x2="7" y2="3"/>
					<line class="spieler_auserer_feuerrand_innen" x1="4" y1="9" x2="6" y2="6.43"/>
					<line class="spieler_auserer_feuerrand_innen" x1="8" y1="9" x2="6" y2="6.43"/>
					<line class="spieler_auserer_feuerrand_innen" x1="6" y1="3.86" x2="3" y2="5.57"/>
					<line class="spieler_auserer_feuerrand_innen" x1="9" y1="5.57" x2="6" y2="3.86"/>
					<line class="spieler_auserer_feuerrand_innen" x1="6" y1="6.43" x2="6" y2="3"/>
					<line class="spieler_auserer_feuerrand_innen" x1="5" y1="3" x2="7" y2="3"/>


					<line class="spieler_innen" x1="4" y1="9" x2="6" y2="6.43"/>
					<line class="spieler_innen" x1="8" y1="9" x2="6" y2="6.43"/>
					<line class="spieler_innen" x1="6" y1="3.86" x2="3" y2="5.57"/>
					<line class="spieler_innen" x1="9" y1="5.57" x2="6" y2="3.86"/>
					<line class="spieler_innen" x1="6" y1="6.43" x2="6" y2="3"/>
					<line class="spieler_innen" x1="5" y1="3" x2="7" y2="3"/>

				`//FEUERSPIELER
				break;

				default://Auge
				svg+=`
					<circle class="auge_dunkel" cx="6" cy="6" r="3"  />`

					if (entität[5]===0){
						// svg+=`<animate attributeName="fill" from="rgba(0,0,0,0)" to="rgba(0,0,0,1)" dur="10s"  />`;
					}

					svg+=`</circle>
					<text x=6 y=6 class="scoretext">`

					if (entität[5]===0){
						entität[5]=1;
						// svg+=`<animate attributeName="opacity" from="0" to="1" dur="0.3s"  />`;
					}
					svg+=`${entität[0]}
					</text>
					`
				break;		
			}



			svg+="</g>"
		}


		for (var i=0;i<würfeln.length;i++){
			var würfel=würfeln[i];
			var wx=1+o_bildschirm_rand_x+o_bildschirm_zelle_g_b*würfel[0];
			var wy=1+o_bildschirm_rand_y+o_bildschirm_zelle_g_h*würfel[1];
			var wg=12*3-2;
			
			svg+=`<rect class="würfel-umriss" x="${wx}" y="${wy}" width="${wg}" height="${wg}" rx="5">`

			 if (würfel[2]===0){
				würfel[2]=1;
				// svg+=`<animate attributeName="opacity" from="0" to="1" dur="0.2s"  />`;
			 }

			 svg+="</rect>";
			// svg+=`<g class="#${entität[0]}" transform="translate(${ox},${oy})">`
		}
		

{
			//header

			var tl_x = o_bildschirm_rand_x;
			var tl_y = o_bildschirm_rand_y-24;
			var tr_x = o_bildschirm_rand_x+12*level_b;
			var tr_y = o_bildschirm_rand_y-24;

			var bl_x = o_bildschirm_rand_x;
			var bl_y = o_bildschirm_rand_y;
			var br_x = o_bildschirm_rand_x+12*level_b;
			var br_y = o_bildschirm_rand_y;


			var ml_x = (tl_x+bl_x)/2;
			var ml_y = (tl_y+bl_y)/2;
			var mr_x = (tr_x+br_x)/2;
			var mr_y = (tr_y+br_y)/2;

			var tm_x=(tl_x+tr_x)/2;
			var tm_y=(tl_y+tr_y)/2;

			var mm_x=(ml_x+mr_x)/2;
			var mm_y=(ml_y+mr_y)/2;

			var bm_x=(bl_x+br_x)/2;
			var bm_y=(bl_y+br_y)/2+12*level_h;

			svg+=`<line x1="${tl_x}" y1="${tl_y}" x2="${bl_x}" y2="${bl_y}" class="raster" />`
			svg+=`<line x1="${tr_x}" y1="${tr_y}" x2="${br_x}" y2="${br_y}" class="raster" />`
			svg+=`<line x1="${tl_x}" y1="${tl_y}" x2="${tr_x}" y2="${tr_y}" class="raster" />`

			svg+=`<line x1="${ml_x}" y1="${ml_y}" x2="${mr_x}" y2="${mr_y}" class="raster" />`

			svg+=`<line x1="${mm_x}" y1="${mm_y}" x2="${bm_x}" y2="${bm_y}" class="raster-dick" />`

			svg+=printText(o_seite_rand_x,o_seite_rand_y,S("Augenschlepper (Level 1 von 3)","Pip Schlepper (Level 1 of 3)"));
			svg+=printText(o_seite_rand_x,o_seite_rand_y+12,S("DU","YOU")+` : ${spielstand[0]}`);
			svg+=printText(o_seite_rand_x+12*level_b/2,o_seite_rand_y+12,S("GEGNER","OPPONENT")+` : ${spielstand[1]}`);
		}


	svg+=`Sorry, your browser does not support inline SVG and so you can't play this game sadface.</svg>`;

	if (genbg){
		svgbg+="</svg>"
		document.getElementById("bgcontainer").innerHTML=svgbg;
	}
	document.getElementById("svgcontainer").innerHTML=svg;
	// document.body.innerHTML=svg;
	}


/*
	let zustand = {
		entitäten : [],
		würfeln : [],
		spielstand : [0,0],
	};
*/
	let undoZustände=[];

	function zustandSpeichern(){
		var zustand_dict = {
			entitäten : entitäten,
			würfeln : würfeln,
			spielstand : spielstand,
		};
		var zustand_str = JSON.stringify(zustand_dict);
		if (undoZustände.length===0 || zustand_str!==undoZustände[undoZustände.length-1]){
			undoZustände.push(zustand_str);
		}
	}

	function rückgängig(){
		if (undoZustände.length===1){
			return;
		}
		undoZustände.pop();
		var zustand_str=undoZustände[undoZustände.length-1];
		var zustand_dict=JSON.parse(zustand_str);
		entitäten = zustand_dict.entitäten;
		würfeln = zustand_dict.würfeln;
		spielstand = zustand_dict.spielstand;
	}

	function neustart(){

		if (undoZustände.length===1){
			return;
		}
		undoZustände.push(undoZustände[0]);
		var zustand_str=undoZustände[undoZustände.length-1];
		var zustand_dict=JSON.parse(zustand_str);
		entitäten = zustand_dict.entitäten;
		würfeln = zustand_dict.würfeln;
		spielstand = zustand_dict.spielstand;
	}

	function startSpiel(){
		undoZustände=[];

		entitäten=[];
		würfeln=[];

		lastlb=-1;
	 	lastlh=-1;
		spielstand=[0,0];
		var curlevel=levels[level];
		var level_b=curlevel[0].length;
		var level_h=curlevel.length;


		for (var i=0;i<level_b;i++){
			for (var j=0;j<level_h;j++){
				var c = curlevel[j].charAt(i);
				switch(c){
					case "#":
					//Mauer. Ignoriere es.
					break;
					case "S":
					//Spieler
					entitäten.push(["S",i,j,i,j]);
					break;
					case "F":
					//Spieler
					entitäten.push(["F",i,j,i,j]);
					break;
					case "o":
					//Auge
					entitäten.push(["o",i,j,i,j]);
					break;
					case "T":
					//Spieler
					entitäten.push(["T",i,j,i,j]);
					break;
					case ".":
					break;
					default://auge
					entitäten.push([c,i,j,i,j]);
					break;
				}
			}
		}

		würfelMelden();
		for (var i=0;i<würfeln.length;i++){
			würfeln[i][2]=1;
		}

		zustandSpeichern();
	}

	function pipAt(x,y){
		for (var i=0;i<entitäten.length;i++){
			let entität=entitäten[i];
			if (entität[0]==="o"){
				if (entität[1]===x && entität[2]===y){
					return true;
				}
			}
		}
		return false;
	}

	let dicefaces = [
		[
		[0,0,0],
		[0,1,0],
		[0,0,0],
		],
		[
		[1,0,0],
		[0,0,0],
		[0,0,1],
		],
		[
		[0,0,1],
		[0,0,0],
		[1,0,0],
		],
		[
		[1,0,0],
		[0,1,0],
		[0,0,1],
		],
		[
		[0,0,1],
		[0,1,0],
		[1,0,0],
		],
		[
		[1,0,1],
		[0,0,0],
		[1,0,1],
		],
		[
		[1,0,1],
		[0,1,0],
		[1,0,1],
		],
		[
		[1,0,1],
		[1,0,1],
		[1,0,1],
		],
		[
		[1,1,1],
		[0,0,0],
		[1,1,1],
		],

	];
	function geltenderWürfelBei(x,y){
		//no overlapping dic
		for (var i=0;i<würfeln.length;i++){
			var [wx,wy]=würfeln[i];
			if (Math.abs(wx-x)<=2.1 && Math.abs(wy-y)<=2.1){
				return false;
			}
		}
		var valid=false;
		for (var k=0;k<dicefaces.length;k++){
			var df = dicefaces[k];
			var good=true;
			for (var i=0;i<3;i++){
				for (var j=0;j<3;j++){
					if (pipAt(x+i,y+j) !== (df[i][j]==1)){
						good=false;
					}
				}
			}
			if (good){
				valid=true;
				break;
			}
		}
		return valid;
		//doesn't overlap with existing würfeln
	}


	function würfelPunktzahl(x,y,candwürfeln){
		var count=0;

		//no overlapping dic
		for (var i=0;i<candwürfeln.length;i++){
			var [wx,wy]=candwürfeln[i];
			var dx = x-wx;
			var dy = y-wy;
			if (dx>=0 && dx<=2 && dy>=0 && dy<=2){
				count++;
			}
		}
		return count;

	}
	function ersetzAugen(candwürfeln){

		var curlevel=levels[level];
		var level_b=curlevel[0].length;
		var level_h=curlevel.length;

		for (var i=0;i<entitäten.length;i++){
			var e = entitäten[i];
			var x = e[1];
			var y = e[2];
			if (e[0]!=="o"){
				continue;
			}
			var zahl = würfelPunktzahl(x,y,candwürfeln)
			if (zahl>0){
				e[0]=""+zahl;
				e[5]=0;
				if (x<level_b/2){
					spielstand[0]+=zahl;
				} else {
					spielstand[1]+=zahl;
				}

			}

		}
		
	}

	function würfelMelden(){

		var curlevel=levels[level];
		var level_b=curlevel[0].length;
		var level_h=curlevel.length;
		var candwürfeln=[];
		for (var i=0;i<level_b-2;i++){			
			for (var j=0;j<level_h-2;j++){
				if (geltenderWürfelBei(i,j)){
					candwürfeln.push([i,j,0]);
				}
			}
		}
		ersetzAugen(candwürfeln);
		for (var i=0;i<candwürfeln.length;i++){
			würfeln.push(candwürfeln[i]);
		}
	}

	function startTitel(){

	}

	let gameState="";
	function setGameState(newgs){
		gameState=newgs;
		switch(newgs){
			case "TITEL":
				startTitel();
				break;
			case "SPIEL":
				startSpiel();
				break;
		}
		render();
	}

	function globalSetup(){

		document.title = S("Augenschlepper","Pip Schlepper");
		
		document.onkeydown = checkKey;	
		document.onkeyup = onKeyup;	
		document.onfocus = onFocus;	
		level=0;

		setGameState("SPIEL")


	}

	window.onload =globalSetup;
</script>

<div id="bgcontainer"></div>
<div id="svgcontainer"></div>
</body>
</html>